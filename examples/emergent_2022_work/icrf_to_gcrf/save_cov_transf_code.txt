
# Saving code of covariance transformation - 2 methods
# Used for Emergent work
# 11/09/2022

Code from Conversion.java
============================
# METHOD - 2
    public static double[] transformFrameCovMethod2(Predefined srcFrame, AbsoluteDate time, List<Double> cov, Predefined destFrame)
    {
        // About BEGIN
        // Input:  time, covariance matrix, input frame, destination frame and
        // Output: cov. LTR in dest. frame
        // About END


        final AbsoluteDate oemDate = time;

        // Form covariance matrix from python input
        double[][] cov_mat = new double[6][6];
        for (int i = 0, k = 0; i < 6; i++)
        {
            for (int j = 0; j < i + 1; j++, k++)
            {
                double value = cov.get(k);
                cov_mat[i][j] = value;
                cov_mat[j][i] = value;
            }
        }

        // pJ2000 contains the input covariance matrix in J2000
        final RealMatrix pJ2000 = MatrixUtils.createRealMatrix(cov_mat);


        //  Frames definition
        Frame src_frame = FramesFactory.getFrame(srcFrame);  //EME2000
        Frame dest_frame = FramesFactory.getFrame(destFrame); //ICRF


        // METHOD 2 - BELOW
        // Jacobian from ITRF to J2000 at date
        double[][] jacJ2000ToIcrf = new double[6][6];
        jacJ2000ToIcrf = src_frame.getTransformTo(dest_frame, oemDate).getRotation().getMatrix();

        final RealMatrix jJ2000ToIcrf = MatrixUtils.createRealIdentityMatrix(6);
        // Set Rotation matrix (3 by 3) into 6 by 6 identity matrix to form 6 by 6 rotation matrix
        jJ2000ToIcrf.setSubMatrix(jacJ2000ToIcrf, 0,0);
        jJ2000ToIcrf.setSubMatrix(jacJ2000ToIcrf, 3,3);

        // Covariance transformation
        // pJ2000 contains the covariance matrix in J2000
        final RealMatrix pIcrf = jJ2000ToIcrf.multiply(pJ2000.multiplyTransposed(jJ2000ToIcrf));
        double[][] matPIcrf = pIcrf.getData();


        // Convert covariance matrix to LTR - below fn from Estimation.java
        int m = pIcrf.getRowDimension();
        double[] out_cov = new double[(int)(0.5*m*(m+1))];
        for (int i = 0, k = 0; i < m; i++)
        {
            for (int j = 0; j <= i; j++)
                out_cov[k++] = pIcrf.getEntry(i, j);
        }
        return(out_cov);
    }


# METHOD 1 -
    public static double[] transformFrameCov(Predefined srcFrame, AbsoluteDate time, List<Double> cov, Predefined destFrame)
    {
        // About BEGIN
        // Input:  time, covariance matrix, input frame, destination frame and
        // Output: cov. LTR in dest. frame
        // About END



        //final AbsoluteDate oemDate = new AbsoluteDate(2022, 4, 26, 1, 0, 00.000, utc);
        final AbsoluteDate oemDate = time;

        // For testing only - true
        boolean testPrintCovMat = false;


        // Form covariance matrix from python input
        double[][] cov_mat = new double[6][6];
        for (int i = 0, k = 0; i < 6; i++)
        {
            for (int j = 0; j < i + 1; j++, k++)
            {
                double value = cov.get(k);
                cov_mat[i][j] = value;
                cov_mat[j][i] = value;
            }
        }

        // pJ2000 contains the covariance matrix in J2000
        final RealMatrix pJ2000 = MatrixUtils.createRealMatrix(cov_mat);


        //  Frames definition
        Frame src_frame = FramesFactory.getFrame(srcFrame);  //EME2000
        Frame dest_frame = FramesFactory.getFrame(destFrame); //ICRF


        // METHOD 1 - BELOW
        // Jacobian from ITRF to J2000 at date
        final double[][] jacJ2000ToIcrf = new double[6][6];
        src_frame.getTransformTo(dest_frame, oemDate).getJacobian(CartesianDerivativesFilter.USE_PV, jacJ2000ToIcrf);

        // Covariance transformation, using Hipparchus RealMatrix class to perform the multiplication
        final RealMatrix jJ2000ToIcrf = MatrixUtils.createRealMatrix(jacJ2000ToIcrf);

        // pJ2000 contains the covariance matrix in J2000
        final RealMatrix pIcrf = jJ2000ToIcrf.multiply(pJ2000.multiplyTransposed(jJ2000ToIcrf));
        double[][] matPIcrf = pIcrf.getData();

        // Convert covariance matrix to LTR - below fn from Estimation.java
        int m = pIcrf.getRowDimension();
        double[] out_cov = new double[(int)(0.5*m*(m+1))];
        for (int i = 0, k = 0; i < m; i++)
        {
            for (int j = 0; j <= i; j++)
                out_cov[k++] = pIcrf.getEntry(i, j);
        }
        return(out_cov);
    }

Code from conversion.proto
============================
rpc transformFrameCovMethod2(TransformFrameInput) returns (Double2DArray) {}


Code from conversion.py
=========================

def transform_frame_cov_method_2(src_frame: int, time: float, cov: List[float], dest_frame: int)->List[float]:
    """Transform a covariance matrix from one frame to another. METHOD 2

    Parameters
    ----------
    src_frame : Source reference frame; a constant from Frame.
    time : Offset in TT from J2000 epoch [s]. Give a list for bulk transforms.
    cov : Modified - would be LTR covariance
    dest_frame : Destination reference frame; a constant from Frame.

    Returns
    -------
    Covariance matrix transformed to the destination frame.
    """

    if (isinstance(time, float) or isinstance(time, str)):
        single, time, cov = True, [time], [cov]
    else:
        single = False

    if (isinstance(time[0], float)):
        resp = _conversion_stub.transformFrameCovMethod2(TransformFrameInput(
            src_frame=src_frame, time=time, pva=[DoubleArray(array=x) for x in cov], dest_frame=dest_frame))
    else:
        resp = _conversion_stub.transformFrameCovMethod2(TransformFrameInput(
            src_frame=src_frame, UTC_time=time, pva=[DoubleArray(array=x) for x in cov], dest_frame=dest_frame))
    return(resp.array[0].array if (single) else resp.array)


Code from ConversionService.java
====================================

    @Override public void transformFrameCovMethod2(Messages.TransformFrameInput req, StreamObserver<Messages.Double2DArray> resp)
    {
        try
        {
            AbsoluteDate time;
            boolean stringTime = req.getUTCTimeCount() > 0;
            Predefined srcFrame = Predefined.valueOf(req.getSrcFrame());
            Predefined destFrame = Predefined.valueOf(req.getDestFrame());
            Messages.Double2DArray.Builder outer = Messages.Double2DArray.newBuilder();

            for (int i = 0; i < req.getPvaCount(); i++)
            {
                if (stringTime) {
                    //System.out.println("got a string UTC time as input: "+ req.getUTCTime(i));
                    time = new AbsoluteDate(DateTimeComponents.parseDateTime(req.getUTCTime(i)), TimeScalesFactory.getUTC());

                }
                else {
                    //System.out.println("got a J2000 offset time as input: "+ req.getTime(i));
                    time = AbsoluteDate.J2000_EPOCH.shiftedBy(req.getTime(i));
                }

                //System.out.println("printing time from Conv.Service.java: " + time.toString());
                double[] cov = Conversion.transformFrameCovMethod2(srcFrame, time, req.getPva(i).getArrayList(), destFrame);


                Messages.DoubleArray.Builder inner = Messages.DoubleArray.newBuilder();
                for (int j = 0; j < cov.length; j++)
                    inner = inner.addArray(cov[j]);
                if (stringTime)
                    inner = inner.addArray(time.durationFrom(AbsoluteDate.J2000_EPOCH));
                outer = outer.addArray(inner.build());
            }
            resp.onNext(outer.build());
            resp.onCompleted();
        }
        catch (Throwable exc)
        {
            resp.onError(new StatusRuntimeException(Status.INTERNAL.withDescription(Tools.getStackTrace(exc))));
        }
    }